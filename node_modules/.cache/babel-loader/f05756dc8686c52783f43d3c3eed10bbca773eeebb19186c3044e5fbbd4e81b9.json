{"ast":null,"code":"const serverUrl = \"http://127.1.3.170:3000/rolls\";\nconst rollDice = async formula => {\n  try {\n    const rollData = parseFormula(formula);\n    await sendRollDataToServer(rollData);\n    return rollData;\n  } catch (error) {\n    console.error(\"Error performing roll: \", error);\n    return null;\n  }\n};\nconst parseFormula = formula => {\n  const advMatch = formula.match(/adv\\(([^)]+)\\)/);\n  const disadvMatch = formula.match(/disadv\\(([^)]+)\\)/);\n  if (advMatch) {\n    validateAdvDisadvFormula(advMatch[1]);\n    return handleAdvDisadvRoll(advMatch[1], \"adv\", formula);\n  } else if (disadvMatch) {\n    validateAdvDisadvFormula(disadvMatch[1]);\n    return handleAdvDisadvRoll(disadvMatch[1], \"disadv\", formula);\n  } else {\n    return handleStandardRoll(formula);\n  }\n};\nconst handleAdvDisadvRoll = (mainFormula, type, fullFormula) => {\n  const additionalParts = fullFormula.replace(`${type}(${mainFormula})`, \"\").split(\"+\").map(part => part.trim()).filter(Boolean);\n  const mainRoll = type === \"adv\" ? handleAdvantageRoll(mainFormula) : handleDisadvantageRoll(mainFormula);\n  const additionalRolls = additionalParts.map(part => handleStandardRoll(part));\n  const total = additionalRolls.reduce((sum, roll) => sum + roll.total, mainRoll.total);\n  const rolls = [mainRoll, ...additionalRolls].flatMap(roll => roll.rolls);\n  return {\n    formula: fullFormula,\n    rolls,\n    total,\n    date: new Date().toISOString()\n  };\n};\nconst validateAdvDisadvFormula = formula => {\n  const parts = formula.split(\"+\").map(part => part.trim());\n  const diceParts = parts.filter(part => part.includes(\"d\"));\n  if (diceParts.length !== 1) {\n    throw new Error(\"Формула некоректна, використовуйте лише 1 тип кубиків при кидку переваги чи перешкоди\");\n  }\n};\nconst handleStandardRoll = formula => {\n  const parts = formula.split(\"+\").map(part => part.trim());\n  const rolls = [];\n  let total = 0;\n  parts.forEach(part => {\n    if (part.includes(\"d\")) {\n      const roll = rollSingleDice(part);\n      rolls.push(...roll.rolls);\n      total += roll.total;\n    } else {\n      const modifier = parseInt(part, 10);\n      total += modifier;\n      rolls.push({\n        value: modifier,\n        isModifier: true\n      });\n    }\n  });\n  return {\n    formula,\n    rolls,\n    total,\n    date: new Date().toISOString()\n  };\n};\nconst handleAdvantageRoll = formula => {\n  const roll1 = rollSingleDice(formula);\n  const roll2 = rollSingleDice(formula);\n  const total = Math.max(roll1.total, roll2.total);\n  return {\n    formula: `adv(${formula})`,\n    rolls: [...roll1.rolls, ...roll2.rolls],\n    total,\n    date: new Date().toISOString()\n  };\n};\nconst handleDisadvantageRoll = formula => {\n  const roll1 = rollSingleDice(formula);\n  const roll2 = rollSingleDice(formula);\n  const total = Math.min(roll1.total, roll2.total);\n  return {\n    formula: `disadv(${formula})`,\n    rolls: [...roll1.rolls, ...roll2.rolls],\n    total,\n    date: new Date().toISOString()\n  };\n};\nconst rollSingleDice = formula => {\n  const [count, sides] = formula.split(\"d\").map(Number);\n  const rolls = Array.from({\n    length: count\n  }, () => getRandomInt(1, sides));\n  const total = rolls.reduce((sum, roll) => sum + roll, 0);\n  return {\n    rolls: rolls.map(value => ({\n      value\n    })),\n    total\n  };\n};\nconst getRandomInt = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst sendRollDataToServer = async rollData => {\n  try {\n    const response = await fetch(serverUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(rollData)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to send roll data to server\");\n    }\n  } catch (error) {\n    console.error(\"Error sending roll data to server: \", error);\n  }\n};\nmodule.exports = {\n  rollDice\n};","map":{"version":3,"names":["serverUrl","rollDice","formula","rollData","parseFormula","sendRollDataToServer","error","console","advMatch","match","disadvMatch","validateAdvDisadvFormula","handleAdvDisadvRoll","handleStandardRoll","mainFormula","type","fullFormula","additionalParts","replace","split","map","part","trim","filter","Boolean","mainRoll","handleAdvantageRoll","handleDisadvantageRoll","additionalRolls","total","reduce","sum","roll","rolls","flatMap","date","Date","toISOString","parts","diceParts","includes","length","Error","forEach","rollSingleDice","push","modifier","parseInt","value","isModifier","roll1","roll2","Math","max","min","count","sides","Number","Array","from","getRandomInt","ceil","floor","random","response","fetch","method","headers","body","JSON","stringify","ok","module","exports"],"sources":["/home/mbohach/Документи/personal/tabletop/src/DiceRoller/Roll-script.js"],"sourcesContent":["const serverUrl = \"http://127.1.3.170:3000/rolls\";\n\nconst rollDice = async (formula) => {\n  try {\n    const rollData = parseFormula(formula);\n    await sendRollDataToServer(rollData);\n    return rollData;\n  } catch (error) {\n    console.error(\"Error performing roll: \", error);\n    return null;\n  }\n};\n\nconst parseFormula = (formula) => {\n  const advMatch = formula.match(/adv\\(([^)]+)\\)/);\n  const disadvMatch = formula.match(/disadv\\(([^)]+)\\)/);\n\n  if (advMatch) {\n    validateAdvDisadvFormula(advMatch[1]);\n    return handleAdvDisadvRoll(advMatch[1], \"adv\", formula);\n  } else if (disadvMatch) {\n    validateAdvDisadvFormula(disadvMatch[1]);\n    return handleAdvDisadvRoll(disadvMatch[1], \"disadv\", formula);\n  } else {\n    return handleStandardRoll(formula);\n  }\n};\n\nconst handleAdvDisadvRoll = (mainFormula, type, fullFormula) => {\n  const additionalParts = fullFormula.replace(`${type}(${mainFormula})`, \"\").split(\"+\").map(part => part.trim()).filter(Boolean);\n  const mainRoll = type === \"adv\" ? handleAdvantageRoll(mainFormula) : handleDisadvantageRoll(mainFormula);\n  const additionalRolls = additionalParts.map(part => handleStandardRoll(part));\n\n  const total = additionalRolls.reduce((sum, roll) => sum + roll.total, mainRoll.total);\n  const rolls = [mainRoll, ...additionalRolls].flatMap(roll => roll.rolls);\n\n  return {\n    formula: fullFormula,\n    rolls,\n    total,\n    date: new Date().toISOString(),\n  };\n};\n\nconst validateAdvDisadvFormula = (formula) => {\n  const parts = formula.split(\"+\").map(part => part.trim());\n  const diceParts = parts.filter(part => part.includes(\"d\"));\n\n  if (diceParts.length !== 1) {\n    throw new Error(\"Формула некоректна, використовуйте лише 1 тип кубиків при кидку переваги чи перешкоди\");\n  }\n};\n\nconst handleStandardRoll = (formula) => {\n  const parts = formula.split(\"+\").map(part => part.trim());\n  const rolls = [];\n  let total = 0;\n\n  parts.forEach(part => {\n    if (part.includes(\"d\")) {\n      const roll = rollSingleDice(part);\n      rolls.push(...roll.rolls);\n      total += roll.total;\n    } else {\n      const modifier = parseInt(part, 10);\n      total += modifier;\n      rolls.push({ value: modifier, isModifier: true });\n    }\n  });\n\n  return {\n    formula,\n    rolls,\n    total,\n    date: new Date().toISOString(),\n  };\n};\n\nconst handleAdvantageRoll = (formula) => {\n  const roll1 = rollSingleDice(formula);\n  const roll2 = rollSingleDice(formula);\n  const total = Math.max(roll1.total, roll2.total);\n\n  return {\n    formula: `adv(${formula})`,\n    rolls: [...roll1.rolls, ...roll2.rolls],\n    total,\n    date: new Date().toISOString(),\n  };\n};\n\nconst handleDisadvantageRoll = (formula) => {\n  const roll1 = rollSingleDice(formula);\n  const roll2 = rollSingleDice(formula);\n  const total = Math.min(roll1.total, roll2.total);\n\n  return {\n    formula: `disadv(${formula})`,\n    rolls: [...roll1.rolls, ...roll2.rolls],\n    total,\n    date: new Date().toISOString(),\n  };\n};\n\nconst rollSingleDice = (formula) => {\n  const [count, sides] = formula.split(\"d\").map(Number);\n  const rolls = Array.from({ length: count }, () => getRandomInt(1, sides));\n  const total = rolls.reduce((sum, roll) => sum + roll, 0);\n\n  return {\n    rolls: rolls.map(value => ({ value })),\n    total,\n  };\n};\n\nconst getRandomInt = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst sendRollDataToServer = async (rollData) => {\n  try {\n    const response = await fetch(serverUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(rollData),\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Failed to send roll data to server\");\n    }\n  } catch (error) {\n    console.error(\"Error sending roll data to server: \", error);\n  }\n};\n\nmodule.exports = { rollDice };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}